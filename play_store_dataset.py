# -*- coding: utf-8 -*-
"""play store dataset.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XOrLoBtbCmBOM25KiF0c756dXTibJqRy

1. What is the most expensive app on the Play Store?
2. Which genre has the highest number of apps?
3. What is the average size of free vs. paid apps?
4. What are the top 5 most expensive apps with a perfect rating (5)?
5. How many apps have received more than 50K reviews?
6. What is the average price of apps, grouped by genre and number of installs?
7. How many apps have a rating higher than 4.7, and what is their average price?
8. What is Google's estimated revenue from apps with 5,000,000+ installs?
(Assuming Google takes a 30% cut from app sales)
9. What are the maximum and minimum sizes of free vs. paid apps?
10. Is there a correlation between an app’s rating, number of reviews, size, and its price?
11. How many apps exist for each type (free/paid) across different content ratings?
12. How many apps are compatible with Android version 4.x?
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

data = pd.read_csv('googleplaystore.csv')

data.info()

data.drop_duplicates(inplace=True)

data.dropna(subset=['Type','Content Rating','Current Ver','Android Ver'], inplace=True)

data.head()

def unique_values_per_column(df):

  unique_values = {}
  for col in df.columns:
      unique_values[col] = df[col].unique()
  return pd.DataFrame(list(unique_values.items()), columns=['Column', 'Unique Values'])


unique_df = unique_values_per_column(data)
unique_df

data['Rating'].fillna(data['Rating'].mean(), inplace=True)

data['Price'] = data['Price'].astype(str).str.replace('$', '', regex=False)
data['Price'] = pd.to_numeric(data['Price'], errors='coerce')

data['Reviews'] = pd.to_numeric(data['Reviews'], errors='coerce')

def clean_installs(installs):
    if isinstance(installs, str):
        installs = installs.replace('+', '').replace(',', '')
        return int(installs) if installs.isdigit() else np.nan # Handle non-numeric values
    return installs  # Keep original value if not a string


data['Installs'] = data['Installs'].apply(clean_installs)

# Function to convert size to numeric value
def convert_size(size):
    if isinstance(size, str):
        if 'M' in size:
            return float(size.replace('M', '')) * 1000000
        elif 'k' in size:
            return float(size.replace('k', '')) * 1000
        elif size == 'Varies with device':
            return np.nan  # or handle it differently, e.g., with the mean
    return float(size) if pd.notna(size) else np.nan

# Apply the conversion function and handle 'Varies with device'
data['Size'] = data['Size'].apply(convert_size)

# Calculate the mean of 'Size', excluding NaN values
mean_size = data['Size'].mean()

# Fill NaN values in 'Size' (Varies with device) with the mean
data['Size'].fillna(mean_size, inplace=True)

# ... (rest of your code)

data.head()

"""**What is the most expensive app on the Play Store?**"""

most_expensive_app = data.loc[data['Price'].idxmax()]

print(f"The most expensive app is '{most_expensive_app['App']}' with a price of ${most_expensive_app['Price']}")

plt.hist(data['Price'], bins='auto')  # or bins='auto'
plt.xlabel('Price')
plt.ylabel('Frequency')
plt.title('Histogram of App Prices')
plt.show()

plt.scatter(data['Reviews'], data['Price'])
plt.xlabel('Reviews')
plt.ylabel('Price')
plt.title('Reviews vs. Price')
plt.show()

"""**Which genre has the highest number of apps?**"""

genre_counts = data['Category'].value_counts()
highest_genre = genre_counts.index[0]
print(f"The genre with the highest number of apps is '{highest_genre}' with {genre_counts[0]} apps.")

"""**What is the average size of free vs. paid apps?**"""

average_size_free = data[data['Type'] == 'Free']['Size'].mean()
average_size_paid = data[data['Type'] == 'Paid']['Size'].mean()

print(f"Average size of free apps: {average_size_free:.2f} bytes")
print(f"Average size of paid apps: {average_size_paid:.2f} bytes")

"""**What are the top 5 most expensive apps with a perfect rating (5)?**"""

perfect_rated_apps = data[data['Rating'] == 5]

top_5_expensive = perfect_rated_apps.nlargest(5, 'Price')

print("Top 5 most expensive apps with a perfect rating (5):")
print(top_5_expensive[['App', 'Price']])

"""**How many apps have received more than 50K reviews?**"""

apps_over_50k_reviews = len(data[data['Reviews'] > 50000])
print(f"{apps_over_50k_reviews} apps have received more than 50,000 reviews.")

"""**What is the average price of apps, grouped by genre and number of installs?**"""

average_price_by_genre_installs = data.groupby(['Category', 'Installs'])['Price'].mean().reset_index()
average_price_by_genre_installs

"""**How many apps have a rating higher than 4.7, and what is their average price?**"""

high_rated_apps = data[data['Rating'] > 4.7]
num_high_rated = len(high_rated_apps)
avg_price_high_rated = high_rated_apps['Price'].mean()

print(f"{num_high_rated} apps have a rating higher than 4.7.")
print(f"The average price of these apps is ${avg_price_high_rated:.2f}")

"""**What is Google's estimated revenue from apps with 5,000,000+ installs? (Assuming Google takes a 30% cut from app sales)**"""

high_install_apps = data[data['Installs'] >= 5000000]
estimated_revenue = (high_install_apps['Price'] * 0.3).sum()

print(f"Google's estimated revenue from apps with 5,000,000+ installs is ${estimated_revenue:.2f}")

"""**What are the maximum and minimum sizes of free vs. paid apps?**"""

max_size_free = data[data['Type'] == 'Free']['Size'].max()
min_size_free = data[data['Type'] == 'Free']['Size'].min()
max_size_paid = data[data['Type'] == 'Paid']['Size'].max()
min_size_paid = data[data['Type'] == 'Paid']['Size'].min()

print(f"Maximum size of free apps: {max_size_free:.2f} bytes")
print(f"Minimum size of free apps: {min_size_free:.2f} bytes")
print(f"Maximum size of paid apps: {max_size_paid:.2f} bytes")
print(f"Minimum size of paid apps: {min_size_paid:.2f} bytes")

"""**Is there a correlation between an app’s rating, number of reviews, size, and its price?**"""

correlation_matrix = data[['Rating', 'Reviews', 'Size', 'Price']].corr()
print(correlation_matrix)

# Visualization of correlations
plt.figure(figsize=(8, 6))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm')
plt.title('Correlation Matrix of App Attributes')
plt.show()

"""**How many apps exist for each type (free/paid) across different content ratings?**"""

app_counts = data.groupby(['Type', 'Content Rating']).size().unstack(fill_value=0)
app_counts

"""**How many apps are compatible with Android version 4.x?**"""

android_4x_apps = data[data['Android Ver'].str.startswith('4.')]
num_android_4x_apps = len(android_4x_apps)
print(f"There are {num_android_4x_apps} apps compatible with Android version 4.x.")